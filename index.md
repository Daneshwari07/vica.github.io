**Course Name:** Algorithmic Problem Solving

**Course Code:** 23ECSE309

**Name:** Daneshwari Hanagandi

**SRN:** 01FE22BCS294

**University:** KLE Technological University, Hubli

**Portfolio domain:** Visa

<!-- ### Contents
1. [Introduction](#introduction) ‚Äì Domain intro üå±  
2. [Objectives](#objectives) ‚Äì Goals and targets üéØ  
3. [Business Use Cases ‚û°Ô∏è Algorithmic Solutions üß©](#business-use-cases-and-mapping-algorithms)  
4. [Use Case Insights and Efficiency Metrics](#use-case-and-efficiency-overview) - Efficiency metrics üìä  
4. [Key Learning](#learnings) ‚Äì Takeaways üß†-->

<!-- Navigation Bar -->
<!-- <div style="display:flex; justify-content:center; gap:20px; padding:20px; background-color:#f5f5f5; border-radius:10px; box-shadow: 0px 4px 10px rgba(0,0,0,0.1);">
  <a href="#home" style="padding:10px 20px; background:white; border-radius:10px; text-decoration:none; font-weight:bold; color:#000; box-shadow:0 2px 5px rgba(0,0,0,0.1);">Home</a>
  <a href="#about" style="padding:10px 20px; background:white; border-radius:10px; text-decoration:none; font-weight:bold; color:#000; box-shadow:0 2px 5px rgba(0,0,0,0.1);">About</a>
  <a href="#skills" style="padding:10px 20px; background:white; border-radius:10px; text-decoration:none; font-weight:bold; color:#000; box-shadow:0 2px 5px rgba(0,0,0,0.1);">Skills</a>
  <a href="#domain" style="padding:10px 20px; background:white; border-radius:10px; text-decoration:none; font-weight:bold; color:#000; box-shadow:0 2px 5px rgba(0,0,0,0.1);">Domain</a>
  <a href="#projects" style="padding:10px 20px; background:white; border-radius:10px; text-decoration:none; font-weight:bold; color:#000; box-shadow:0 2px 5px rgba(0,0,0,0.1);">Projects</a>
  <a href="#contact" style="padding:10px 20px; background:white; border-radius:10px; text-decoration:none; font-weight:bold; color:#000; box-shadow:0 2px 5px rgba(0,0,0,0.1);">Contact</a>
</div> -->



<!-- Introduction Section -->
<!-- <div id="home" style="background:white; padding:30px; border:2px solid #ddd; border-radius:15px; box-shadow: 0 0 10px rgba(0,0,0,0.05); margin-top:30px; max-width:800px; margin-left:auto; margin-right:auto;">
  <h2 style="font-weight:bold;">Welcome to My Portfolio</h2>
  <p style="font-size:16px; color:#333; line-height:1.6;">
    I'm <strong>Daneshwari Hanagandi</strong>, a passionate student from <strong>KLE Technological University, Hubli</strong>, currently enrolled in the Algorithmic Problem Solving course.
    This portfolio reflects the knowledge, skills, and algorithmic thinking I‚Äôve gained as part of my engineering journey.
  </p>
  <p style="font-size:16px; color:#333; line-height:1.6;">
     As a passionate Computer Science graduate with hands-on experience in Machine Learning, Deep Learning, and intelligent system design, I am driven by the transformative potential of AI in shaping secure, seamless digital experiences.
    My projects ranging from medical image classification using deep learning to enhancing speech quality using AI have strengthened my skills in building real-world, data-driven solutions.
    I enjoy solving complex problems that require a mix of innovation, performance, and responsibility.
    Visa‚Äôs commitment to tech-driven global impact and innovation resonates strongly with my values, and I‚Äôm eager to contribute meaningfully to your mission of enabling trusted, intelligent digital commerce worldwide.
  </p>
</div>-->

---

## Contents
- üå±[Introduction](#introduction) ‚Äì Domain overview and the payment ecosystem  
- üéØ[Objectives](#objectives) ‚Äì Targeting real-time problems with smart solutions 
- üß©[Business Use Cases ‚û°Ô∏è Algorithmic Solutions](#business-use-cases-and-mapping-algorithms) - Bridging Visa cases with DSA models
- üìä[Use Case Insights and Efficiency Metrics](#use-case-and-efficiency-overview) - Measuring performance and algorithmic impact  
- üß†[Key Learning](#learnings) ‚Äì Final reflections and takeaways


---

# 1.Introduction
<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/Screenshot%202025-05-28%20015532.png?raw=true" 
       alt="Visa services Screenshot" 
       width="500"> 
  <br>
</p>

<p>Visa, a global leader in digital payments, offers a secure transfer of funds across the world through its advanced financial network.These include VisaNet, Visa Direct,Contactless payments,Ecommerce payment solutions.Visa plays a key role in the future of financial technology,making it a great example of how algorithms and data structures can improve transaction speed,prevend fraud and create a better experience for customers at a global scale.</p>
The services provided by Visa include:
- **VisaNet** : Global payment processing network.
- **Visa Direct** : Real-time payment transfer.
- **Visa Cards** : Used for payments.
- **Contactless payments** : Tap-to pay transactions.
- **Fraud Protection**: Keeps card details safe.

### **VisaNet**
**VisaNet**, is the core global processing network of Visa.Approximately 65,000 card transactions per second are supported by VisaNet[1], which manages card transaction authorization, clearing, and settlement.It highlights the need of fast and efficient algorithms.

### **Visa-Direct**
**Visa-Direct**, supports real-time payments and is expected to help facilitate over $10 trillion in global money movement by 2026 [2].This highlights the need of root-optimized algorithms to handle data efficiently.

### **Tap-to-Pay**
**Tap-to-pay**, now account for more than 50% of Visa face-to-face transactions globally as of 2023 [3].This rapid tap-to-pay growth highlights the need for ultra-fast, low-latency algorithms that enable instant transaction validation and tokenized security.

### **Visa Shopping**
**Visa Shopping**, allows users to shop anytime, anywhere ‚Äî enabling seamless payments across millions of global merchants using a Visa card. This flexibility highlights the need for secure, low-latency systems and optimized algorithms to ensure smooth, real-time transaction experiences.

## Enhancing Visa's Services with Algorithms
In today‚Äôs digital age, the efficiency and effectiveness of financial technology services can be significantly enhanced through the strategic application of data structures and algorithms. This portfolio project explores the core functionalities of Visa‚Äôs global payment systems, applying the theoretical knowledge and practical skills acquired from courses in **Data Structures and Algorithms (DSA)** and **Algorithmic Problem Solving (APS)**. By using advanced algorithmic techniques and innovative data structures, this project aims to propose solutions to real-world challenges.

This portfolio demostrates how algorithms make Visa's services more efficient, including transaction optimization, fraud detection, real-time payment routing, and system scalability within Visa‚Äôs environment.

---
<br>
# 2.Objectives

- To explore and implement algorithms that improve the efficiency of Visa's services.
- To apply theoretical knowledge from DSA and APS courses to practical,real world scenarios.
- To explore how smart algorithmic techniques can make transaction processing within VisaNet faster, more accurate, and scalable.
<br><br><br>

---
<br>
# 3.Business Use Cases‚û°Ô∏èAlgorithmic Solutions

[**Card and BIN Resolution for Visa Transaction Routing**](./business/1.md)
Trie: **Trie** can be used to quickly match the card's BIN prefix by checking each digit step-by step,it following a path through a tree.This makes it very fast to identify the issuing bank or country based on the card number's first few digits.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/trie.gif?raw=true" alt="Trie data structure" width="500">
  <br>
[4] Trie structure for matching prefix in card
  <br>
</p><br>

Hash Tables: **Hash tables** can be used in session and profile storage.It helps Visa to store and retrieve the user session data and card information with near instant access.This ensures quick verification during transactions.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/HashTable.gif?raw=true" alt="Hash data structure">
  <br>
[5] Hash tables for storing user session data
  <br>
</p><br>

skip list: **skip list** can be used in Dynamic card information updates,it handle frequent insertions,deletions and updates to active card records.By keeping the data sorted it ensures faster access.
<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/skipList.gif?raw=true" alt="skip list data structure" width="500">
  <br>
[6] skip list for dynamic updates
  <br>
</p><br>

**challenge** efficiently handling millions of card details

**Market Benefits** Faster card recognition during transactions,reduced transaction delays and improve user experience.

**Design techniques and Performance analysis:**

 - **Tries** Tree data structure,prefix tree
   - Time complexity: O(L) for insertion,deletion and lookup operations,where L is the length of the key.
   - space complexity: O(ALPHABET_SIZE*L) where ALPHABET_SIZE is the number of possible characters

- **Hash Table** 
   - Time complexity: O(1) for insert/delete/search
   - Space complexity: O(n) where n is number of stored items.

- **Skip Lists** Probabilistic balancing,layered linked lists
  - Time complexity: O(log n) on average for search, insertion, and deletion, where n is the number of elements in the list
  - Space complexity: O(n), where n is the number of elements in the skip list

[View Trie code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/trie.cpp){:target="_blank"}<br>
[View hashing code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/hash.cpp){:target="_blank"}<br>
[View skip list code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/skipList.cpp){:target="_blank"}<br><br><br>



### 2.**Routing Algorithms for Transaction Optimization**
**Dijkstra's Algorithm** can find the most cost-effective and fastest route for a transaction between the customer's bank and the merchant's bank,when multiple intermediaries are involved. considering factors such as network latency,currency exchange rates and real-time system load.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/dijistra1.gif?raw=true" alt="Dijstra algorithm">
  <br>
[7] Dijkstra's Algorithm for finding shortest routing paths
  <br>
</p><br>

Floyd-Warshall Algorithm: In Visa's network **Floyd-Warshall Algorithm** can be used for network analysis.It helps to find the shortest paths between all pairs of nodes.It precomputes all possible router between banks and payment processors,enabling fast path selection during high transaction volumes without re-running pathfinding algorithms.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/Floyd_warshall_gif.gif?raw=true" alt="Floyd-Warshall algorithm">
  <br>
[7] Floyd-Warshall algorithm for finding shortest routing paths between all pairs.
  <br>
</p><br>

**Challenges:** Computing shortest paths considering traffic and road conditions.

**Market Benefits:** Faster transaction approvals,reduced processing costs,enhanced customer trust and better cross-border payment efficiency.

**Design techniques and Performance analysis:**
- **Dijkstra's Algorithm:** Greedy approach, Priority queue
  - Time Complexity: O((V + E) log V) where V is the number of vertices and E is the number of edges
  - Space Complexity: O(V) where V is the number of vertices<br>

- **Floyd-Warshall Algorithm:** Dynamic programming, All-pairs shortest path
  - Time Complexity: O(V<sup>3</sup>) where V is the number of vertices
  - Space Complexity: O(V<sup>2</sup>) where V is the number of vertices

[View Dijkstra‚Äôs code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/dijistra.cpp){:target="_blank"}<br>
[View Floyd-Warshall code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/floyd_warshall.cpp){:target="_blank"}<br><br><br>


### 3.**Location-Based Risk Check**
Visa can be used **KD-Tree** to perform fast and efficient geo-location lookups during a transaction.It is tree structure used for storing spacial data.It quickly find the nearest known locations to the user's current point by breaking down the location space into a grid.If a new location is too far from previously known ones and time gap is short,the system can flag it as potential fraud risk.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/KDtree.gif?raw=true" alt="KD tree algorithm">
  <br>
[8] KD-Tree for finding location based risks] 
  <br>
</p><br>

 **challenges** Handling geographic coordinates and divice information efficiently,keeping location history updated for millions of users.

 **Market analysis** Improved fraud detection,faster transaction decisions,improves customer safety.

**Design techniques and Performance analysis:**

  - **KD tree:**
      - Time complexity: O(n logn), where n is number of locations
      - Search Time: O(n) if tree is unbalanced
      - Space complexity: O(n) where n is number of stored points.


### 4.**Network load balancing in VisaNet**

VisaNet handles billions of real-time transactions daily across global data centers.It has multibal global data centers. **Segment Tree** can be used to store and update the aggregated transaction loads per region. This helps to quickly determine which region has capacity to handle more traffic.It updates load counters when transaction start or finish.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/segment1.gif?raw=true" alt="segment tree" width="600">
  <br>
[10] Segment tree to store and update aggregate transaction load
  <br>
</p><br>

In VisaNet's data centers the **Fenwick Tree** known as Binary indexed Tree plays a crucial role in managing and balancing server-level loads efficiently.Mantaining a this dynamic structure supports quick updates and rage queries,VisaNet can track the load on each individual server in real time.Fenwick tree enables fast cumulative queries such as checking the total load accross a range of servers which helps in identifying imbalances or potential hotspots.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/fenwick.gif?raw=true" alt="Fenwick tree" width="600">
  <br>
[11] Fenwick Tree to balce server-level loads
  <br>
</p><br>


Hash Table: a **Hash Table** combined with consistent Hashing is used to efficiently assign transactions from millions of users to backend servers. This technique ensures that the load is evenly distributed, reducing the chance of overloading any single server. When servers are added or removed,only a minimal number of transaction mapping need to change.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/hashing.gif?raw=true" alt="Fenwick tree" width="500">
  <br>
[12] Hash Table combined with consistent Hashing
  <br>
</p><br>

**Challenges**
   - Failover recovery and dynamic node scaling,massive data handling.
   - Synchronization between global and lacal data structures,ensuring low latency decision making(<100ms)

**Market Benefits**
Improved speed,scalability,user experience and infrastructure cost efficiency.It also improve user experience and loyalty.

**Design techniques and Performance analysis:**

   - **Segment tree:** Binary tree structure
        - Time complexity: O(n)
             - update time: O(log n)
             - Query time: O(log n)
        - Space complexity: O(n) to store nodes
    
  - **Fenwich tree**
       - Time complexity: O(n log n)
            - Update time: O(log n)
            - Query time(prefix sum): O(log n)
       - Space complexity:O(n)

   - **Hash Table with consistent Hashing**
       - Time complexity: O(1) for retriving,searching data.
       - Rebalancing on node failure: O(k/n), where k is number of keys, n servers
       - Space complexity: O(n + k) where n is number of servers, k is number of keys

[View Segment tree code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/segment.cpp){:target="_blank"}<br>
[View Fenwick Tree code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/fenwick.cpp){:target="_blank"}<br>
[View Hash table code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/hash_table.cpp){:target="_blank"}<br><br><br>

### 5. **Secure Authentication & Encryption**
In the world of digital payments,Visa ensures that every transaction is secure and authenticated.This is achieved through a combination of strong encryption,hashing techniques and optimized data structures that work together to protect sensitive information in real time.

**Fermat‚Äôs Little Theorem** plays a foundational role in RSA encryption, which is used by Visa to secure communication between users,banks and merchants.It enables the calculation of modular inverses and supports the integrity of public-private key operations used in digital signatures and secure handshakes. When creating public key two large prime numbers are chosen and multiplied together.Fermat's Little theorem assists in ensuring that these numbers have properties that make the encryption secure yet feasible to compute for those with the correct key[].The theorem aids in determining the modular inverse during the RSA key generation process which is also crucial for decrypting the received messages.


<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/RSA_1.png" alt="Run Length Encoding" width="500">
  <br>
  <strong>[12]</strong> RSA encryption 
</p>
<br>

Red Black Tree: **Red Black Tree** are a type of self-balancing binary search tree that Visa can use it to store and manage cryptographic assests such as public and private keys,device fingerprints,session tokens and user metadata.These data points need to be accessed rapidly and reliably in real time payment environment.Red black tree can handle both ordered and unordered data.

<table align="center">
  <tr>
    <td align="center">
      <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/rbt_insert.gif" width="380"><br>
      <strong>Red Black Tree insertion</strong>
    </td>
    <td align="center" style="padding-left: 30px;">
      <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/rbt_delete.gif" width="380"><br>
      <strong>Red Black Tree deletion</strong>
    </td>
  </tr>
</table>

**Challenges:** compliance and regulatory pressure,secure session management
**Marketing Benefits** Reduced Fraud and chargebacks,improved user experience and scalability for future technologies.
**Design techniques and Performance analysis:**
   - **Fermat's little therom**
        - Time complexity: O(log e) for modular exponentiation where e is the exponent
        - Space complexity: O(log n) for storing large integers
   - **Red black Tree**
        - Time complexity:
            - insertion: O(log n)
            - deletion : O(log n)
        - Space complexity : O(n)

[View RSA code using fermat's little therome](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/RSA.cpp){:target="_blank"}<br>
[View Red Black tree code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/RedBlackTree.cpp){:target="_blank"}<br><br><br>

### 6.**Keyword Detection in Customer Service Chatbots**
Visa's global customer service platforms receive thousands of queries per second. To automate issue resolution and escalate critical cases, Visa uses real-time keyword detection in user chats.Visa can be used **Aho-Corasick** for multi-pattern matching, it allows tge system to instantly detect known issues keywords across a large dictionary. **Pratt's pattern search** which handles substring matching efficiently without preprocessing.It is used for smaller, more targeted phrase matching.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/corasick.png?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[13]</strong>Aho-Corasick used Keyword detection 
</p>
<br>

- **Market Benefits:** Improved customer satisfaction,reduced response time.

- **Design techniques and Performance analysis:**
     - **Aho-Corasick:** Trie and KMP prefix
          - Time complexity:
             - Build : O(S) where S is the sum of lengths of all patterns
             - Search: O(N+Z) where N is the length of the input text, Z is the total number of matches found.
          - Space complexity: O(SxœÉ) where S is the total length of all patterns,œÉ is alphabet size.

### 7. **Allocation of resources in data centers(visaNet)**
 VisaNet,the global payment processing network of Visa, relies on a network of high-performance data centers to handle billions of transactions securely and in real time. Efficient resource allocation within these data centers is critical to maintaining low latency, high availability, and optimal performance.
 
**Assignment Problem** can be utilized to optimize resource allocation within these data centers such as transaction validation,fraud detection and token generation are treated as jobs that need to be assigned to a set of available nodes or servers.By applying Assignment Problem for smaller problem size,VisaNet can assign tasks to resources in a way that minimizes overall latency, balances load, and adheres to service-level agreements.

**Challenges :** Effective allocation of resources

**Market Benefits:** Improved resource management and reduced operational costs.

**Design techniques and Performance analysis:**
   - **Assignement Problem:** Optimization technique 
        - Time complexity: O(2<sup>N</sup> * N) where N is the number of tasks or resource
        - Space complexity: O(N<sup>2</sup>) where N is the number of tasks or resources

[View code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/jobassignment.cpp){:target="_blank"}<br><br><br>

### 8. **Scheduling Tasks in data centers**
Visa's vast network of data centers relies on efficient task scheduling algorithms to manage computational workloads and optimize resource utilization.**Topological Sort** can be used to schedule tasks and dependencies in directed acyclic graphs(DAGs),ensuring that tasks are execution in the correct order to meet the deadlines,minimize latency and maximize throughput
<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/topological.gif" alt="Run Length Encoding" width="500">
  <br>
  <strong>[14]</strong> Topological Sort optimizing task scheduling in VisaNet
</p>
<br>

**Challenges:** Efficient task scheduling and resource allocation.

**Market Benefits:** Improved resource utilization,minimized latency.

**Design techniques and Performance analysis:**
   - **Topological Sort:** Directed acyclic graph(DAG), Depth-first search(DFS)
        - Time complexity: O(V+E), where V is the number of vertices (tasks) and E is the number of edges (dependencies) in the DAG
        - Space Complexity: O(V + E) for storing the graph and additional structures

[View code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/topology.cpp){:target="_blank"}<br><br><br>

### 9.**Resource Optimization in data centers**
VisaNet processes millions of transactions with high speed and accuracy. Resource optimization ensures that tasks are assigned to the most suitable servers and workloads are efficiently  balanced across data centers.

The **Max-Flow** algorithms can be used to optimize network traffic in VisaNet by modeling data centers, routers, and communication links as a flow network. ach link is assigned a capacity and cost.VisaNet can then route transaction data in a way that maximizes throughput while minimizing total transmission cost across the network.Max flow algorithms, such as Karger‚Äôs, Dinic‚Äôs, and Ford-Fulkerson, can assist in determining optimal routes and balancing the load across servers, improving system performance and reliability.
<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/ford.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[15]</strong> Ford-Fulkerson algorithm for network traffic optimization
</p>
<br>

**Challenges:** Managing vast network traffic, and minimizing congestion.

**Market Benefits:** Improved system performance, and reliability.

**Design techniques and Performance analysis:**

   - **Ford-Fulkerson Algorithm:**
        - Time complexity : O(E*V<sup>2</sup>) where E is the number of edges and V is the number of vertices
        - Space Complexity: O(V<sup>2</sup>) where V is the number of vertices<br>

[View max-flow code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/min_max.cpp){:target="_blank"}<br><br><br>

### 10.**Optimal Transaction Bundle for Offers**
Visa collaborates with merchants to offer personalized cashback, reward points and discounts.The challenge is to maximize user benefit by selecting the best combination of offers applicable to a user‚Äôs transaction history and current context.

Visa can use **0-1 Knapsack** to select the best mix of rewards or cashback offers for a user within set limits like budget or offer count.This ensures the user receives the maximum possible benefit from eligible offers without violating any constraints.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/knapsack.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong></strong>0-1 Knapsack for optimal transaction bundle offers
</p>
<br>

Visa can use **House Robber** algorithm which ensures time-sensitive or conflicting offers don't overlap. This personalization boosts user satisfaction and increases both merchant and card transaction volumes.

- **Market Benefits:** Improves user engagement,increased transaction volume and higher merchant conversion rates.

- **Design techniques and Performance analysis:**
  
     - **0-1 KnapSack Algorithm:** Dynamic Programming
          - Time complexity: O(n*W) where n is number of items and W is the maximum capacity(benefits)
          - Space complexity: O(n*W)
     - **House Robber:** Dynamic Programming
          - Time complexity: O(n)
          - Space complexity: O(1)

[View 0-1 Knapsack code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/knapsack.cpp){:target="_blank"}<br>
[View House robber code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/robber.cpp){:target="_blank"}<br><br><br>


### 11.**Transaction Data Compression & Storage**
Visa handles enormous volumes of transaction logs daily so it requires efficient storage and transmission.
Visa can be used **Huffman Coading** to efficiently compress transaction metadata,log files by assigning shorter binary codes to frequently occuring values. This reduces the size of logs before storing or transmittting them across data centers.It also reduces data storage cost and improves retrival times.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/Huffman.gif" alt="Huffman Tree" width="300" height="200">
  <br>
  <strong>[16]</strong> Huffman coding for data compression
</p>

**Lempel-Ziv algorithms** can be used for compressing trasaction streams that exhibit repeated patterns such as recurring location codes, currency formats.Using LZ based compression in real-time logging system to detect and eliminate redundancy and making it suitable for both storage and low latency transmission between systems.

**Run-Length Encoding** can be used to compress simpler analytics data with repetitive values such as status flags,transaction success/failure logs or time series data with constant intervals.It is a lightweight and effective for specific log formats where repeated vaues appear in long sequences.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/run_length.png" alt="Run Length Encoding" width="300" height="200">
  <br>
  <strong>[17]</strong> RLE for analyzing repetitive values
</p>

**Challenges**
 Real-time compression can add CPU and memory load when their is large or continuous data streams.It also increase response time in systems

**Market benefits:**
Improved Scalibility,enables faster data movement between microservices and regional payment gateways.

**Design techniques and Performance analysis:**
   - **Huffman coding**
        - Time complexity: 
           - Encoding: O(n log n)
           - Decoding: O(n)
        - Space complexity:O(n) for storing the Huffman tree and encoded data
         
  - **Lempel-Ziv**
       - Time complexity:
          - Encoding: O(n) (depends on match length)
          - Decoding: O(n)
       - Space complexity: O(n) 
         
  - **Run-Length Encoding**
       - Time complexity:
          - Encoding: O(n) (depends on match length)
          - Decoding: O(n)
       - Space complexity: O(1) to O(n) (depends on repetition)
         
[View Huffman code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/huffman.cpp){:target="_blank"}<br>
[View lempel-ziv code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/lempel.cpp){:target="_blank"}<br>
[View run-length encoding code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/runLength.cpp){:target="_blank"}<br><br><br>

### 12.**Transaction Sequence Compression for AI Models**

Visa increasingly uses AI models for fraud detection,personalization and behavioral scoring.These models depend on clean, tokenized representations of transaction sequences.
**Suffix Trees** can be used for indexing and compressing repeated subsequences in large transaction logs making it more efficient for pattern mining and anomaly detection.
**Tries and Skiplis** can also be used for transaction sequence compression.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/suffix.png?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[18]</strong>Trasaction sequence compression using suffix trees
</p>
<br>

- **Design techniques and Performance analysis:**
     - **Suffix Tree**
          - Time complexity:
             - Build : O(n) using ukkonen's algorithm
             - Search: O(m) where m is length of pattern
          - Space complexity: O(n)
            
[View suffix tree code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/suffix.cpp){:target="_blank"}<br><br><br>
            
### 13.**Transaction History Analytics in VisaNet** 
Visa processes billions of transactions globally and each cardholder has a growing transaction history that needs to be stored,queried and analyzed efficiently.

**Persistent Segment tree** can be used to maintain historical versions of each user's transaction data. Instead of overwriting old data, a new version is created with each update which enables fast queries on past transaction states.This helps in fraud investigation and audit trails.
<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/persistant_segment.png?raw=true" alt="segment tree" width="600">
  <br>
[19] Persistant segment tree for maintaining versions
  <br>
</p><br>

**Fenwick Tree** can be used to maintain and query cumulative transaction totals.Fenwick tree enables fast prefix sum calculations and dynamic updates as new tranactions occur.This makes it useful in real-time analytics.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/fenwick1.jpg" alt="Huffman Tree" width="300" height="300">
  <br>
  <strong>[10]</strong> Fenwick Tree to query cumulative trasaction total
</p>

**Challenges**
  - Handling massive volumes of transactional data across global infrastructure
  - The solution must support high availability and dynamically scaled infrastructure as transaction volumes fluctuate globally.
  - Transaction anlytics must delivar the results under 100ms for smooth user experience in dashboards.

**Market benefits :**
Real-Time Analytics, infrastructure efficiency,historical versioning supports regulation compliance,internal audits. It also improves user trust and engagement.

**Design techniques and Performance analysis:**
   - **Persistant Segment tree**
        - Time Complexity:
           - Update: O(log n)
           - Query : O(log n)
        - Space Complexity:
           - O(log n) per version
   - **Fenwick Tree**
        - Time Complexity: It takes O(n) to build
           - Update: O(log n)
           - Query(Prefix Sum): O(log n)
        - Space Complexity: O(n)

[View Persistent Segment tree code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/PersistentSegment.cpp){:target="_blank"}<br>
[View Fenwick tree code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/Fenwick.cpp){:target="_blank"}<br><br><br>

### 14.**Detecting fraud in Financial transactions**
Visa builds behavioral models based on user's historical transaction patterns such as frequency,location,amount and merchant type.It can be use a **trie** to store known fraud card prefixes and merchant IDs based on past fraud.For every new transaction it checks the card number and merchant against this trie.Tries are fast at matching prefixes it can instantly find the fraud activity.

 <p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/trie1.gif?raw=true" alt="trie algorithm" width="600">
  <br>
[4] Trie data structure
  <br>
</p><br>

Hash Table: Visa can be used hash tables to store the hashed information like user devices,browser fingerprints, ip addresses and login sessions.Each of these identifiers is converted into a unique hash and stored in the system.when a new transaction is made,the system quickly checks wheather the hashed signature of the device matches the past trusted ones.If it doesn't match then the system block the transaction to prevent fraud.

<p align="center">
  <img src="https://github.com/Daneshwari07/vica.github.io/blob/main/images/hash_table.gif?raw=true" alt="Hash data structure">
  <br>
[5] Hash tables for storing user session data
  <br>
</p><br>

**Challenges**
  - Fraud must be detected within milliseconds of the transaction request.
  - Visa handles tens of thousands of transactions per second, requiring high efficiency and accuracy.
  - Balancing fraud prevention without blocking authorized users.

**Market Benefits**
  - Early fraud detection can reduce financial losses, it increases trust of users and merchants.Authorized transactions runs smoothly and fraud ones are flagged seamlessly.

**Design techniques and Performance analysis:**

   - **Trie:** tree structure
       - Time complexity: O(m) where M is length of prefix
       - Space complexity: O(nxm)
         
   - **Hash Table:**
       - Time complexity: O(1) for retriving,searching data.
       - Space complexity: O(n) 
    
[View Trie code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/trie1.cpp){:target="_blank"}<br>
[View hashing code here](https://github.com/Daneshwari07/vica.github.io/blob/main/codes/hash_table.cpp){:target="_blank"}<br><br><br>

### 15.**Risk Pattern Mining in VisaNet**
Visa processes millions of transaction records daily, many containing descriptions, merchant codes, or metadata. Fraudsters often embed subtle, repeated patterns in this text to disguise illegal activities.

Visa can scan transaction description, merchant category codes using fast string matching techniques. **Boyer-Moore** algorithm can be used to efficiently search through large volumes of transaction logs for known fraud patterns. By scanning from right to left and skipping ahead based on mismatched characters, it reduces unnecessary comparisons.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/boyer.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[20]</strong>Risk pattern mining using Boyer-Moore string matching
</p>
<br>

**Knuth-Morries-Pratt(KMP)** can be used to transaction descriptions in linear time without backtracking, This is useful for detecting fraud patterns that appear frequently but may be slightly modified in placement. 

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/kmp.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[21]</strong>Knooth Morries Pratt algorithm
</p>
<br>

**Rabin-Karp** algorithm can be used to search multiple suspicious patterns at once by hashing each substring and comparing it with known fraud hashers.These techniques together help Visa to identify subtle and recurring fraud signatures across its global transaction stream.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/rabin.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[22]</strong>Rabin karp algorithm to search multiple patterns at once.
</p>
<br>

- **Market Benefits:** Helps to prevent transaction laundering, synthetic ID fraud, and fake merchant campaigns

- **Design techniques and Performance analysis:**

     - **Boyer-Moore Algorithm:** uses bad character and good suffix heuristics
          - Time complexity: O(nxm) (worst-case pattern)
          - Space complexity: O(m+œÉ) where m is pattern length and œÉ is alphabet size/
     - **Knuth-Morris-Pratt:** uses prefix table
          - Time complexity: O(n+m) where n is text length, m is pattern length
          - Space complexity: O(m) prefix table
     - **Rabin Karp:** uses rolling hash
          - Time complexity:
              - Single pattern: avrage O(n+m) and worst case O(nm)
              - Multiple pattern: O(nxk) where k is the number of patterns
          - Space complexity: O(1) for single and O(k) for multiple patterns.

[View Boyer Moore algorithm code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/boyer.cpp){:target="_blank"}<br>
[View KMP algorithm code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/kmp.cpp){:target="_blank"}<br>
[View Rabin-Karp algorithm code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/rabin.cpp){:target="_blank"}<br><br><br>

### 16.**Cross-Merchant Fraud Detection in VisaNet**
In financial fraud some merchants may collude to launder money or distribute fraudulent transactions across multiple accounts and terminals.These merchants might pass fake transactions among themselves, creating cyclic patterns that are difficult to detect with linear or rule-based systems. 

Visa can be used **Kosaraju's** or **Tarjan** to detect strongly connected components(SCC) in the network.An SCC is a group of merchants where every merchant is reachable from every other, signaling tight interconnection.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/scc.png?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[23]</strong>Kosaraju algorithm for strongly connected components
</p>
<br><br>

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/Tarjan.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[24]</strong>Tarjan's algorithm for strongly connected component
</p>
<br>

- **Market Benefits:** It strengthens anti-money laundering and fraud intelligence systmes.

- **Design techniques and Performance analysis:**
     - **Kosaraju's Algorithm:** Two-phase DFS (original and transposed graph)
          - Time complexity: O(V+E)
          - Space complexity: O(V)
  
[View Kosaraju's algorithm code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/kosaraju.cpp){:target="_blank"}<br><br><br>

### 17. **Merchant Similarity Scoring**
Visa's merchant verification system must detect fraudulent clones and fake merchant entries.**Longest Common Subsequence**(LCS) can be used to apply on merchant names,address fields and transaction descriptions to compute similarity scores.Visa uses this during merchant onboarding,periodic audits and fraud detection pipelines.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/subsequence.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong></strong>Longest common subsequence to compute similarity scores
</p>
<br>

- **Market Benefits:** Reduced merchant fraud,improved data integrity and trustworthy partner ecosystem.

- **Design techniques and Performance analysis:**
     - **Longest Common Subsequence:** Dynamic Programming
          - Time complexity : O(m*n) where m and n are lengths of subsequence
          - Space complexity: O(m*n) for storing the LCS table
            
[View code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/LCS.cpp){:target="_blank"}<br><br><br>

### 18.**Global Payment Clustering**
Visa operates across regions with billions of transactions flowing through VisaNet daily. To analyze and optimize payment behavior across countries, industries or merchant types.Visa can be used **Union-Find** to dynamically group entities that share common traits such as merchant category, transaction location, payment processor.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/UnionFind.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[25]</strong>global payment clustering using union-find
</p>
<br>

- **Design techniques and Performance analysis:**
     - **Union-find Data structure**
          - Time complexity:
             - Find(x) : O(Œ±(n)) Œ±(n) is the inverse Ackermann function
             - Union(x,y) : O(Œ±(n))
          - Space complexity: O(n) where n is the number of transactions or merchant entities. 

    
### 19.**Dispute Resolution Workflow Optimization in VisaNet**
Visa handles millions of transaction disputes globally through its robust dispute resolution system. Optimizing this workflow ensures faster, fairer handling of chargebacks and conflict cases.
**Topological Sort** can be used in the dispute resolution process where each node represent a specific task and edges represent dependencies between steps.Topological sorting ensures that tasks are excured in the correct sequence, respecting deadlines and dependencies.This avoids invalid processing and delays.
<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/topo.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[26]</strong> Topological Sort for Dispute Resolution Workflow
</p>
<br>

Stable Marriage Algorithm: **Stable Marriage Algorithm** can be used to ensure that agents are fairly and optimally assigned to cases based on skill sets,preferences or case complexity without conflicts or repeated reassignments.This helps balance workloads improve decision quality and enable faster resolution times.
<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/stable.png?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong></strong> Stable marriage algorithm for resolution workflow optimization
</p>
<br>

- **Challenges:** Fair resource allocation,scalability issues.

- **Market Benefits:** Faster resolution time,Fair and efficient agent assignment and increased throughput and scalability.

- **Design techniques and Performance analysis:**
     - **Topological Sort** DFS based topological sort
          - Time complexity:O(V+E)
          - Space complexity:O(V+E) (for storing DAG)
     - **Stable Marriage Algorithm** use gale-shapley algorithm to find stable match
          - Time complexity:O(n<sup>2</sup>) where n is number of agents
          - Space complexity:O(n<sup>2</sup>)
            
[View Topology sort code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/topology.cpp){:target="_blank"}<br>
[View Stable marriage code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/stable.cpp){:target="_blank"}<br><br><br>

### 20.**Network Reliability using Bridges and Articulation Points**
In Visa, a millions of financial transactions occur every second fot that maintaining a reliable and fault-tolerant network is essential.The algorithms such as finding **bridges and articulation points** help identify critical points of failure in the network.By identifying these points, Visa can implement redundancy measures and optimize network design to minimize downtime and improve overall network reliability.
<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/Bridge1.png?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[27]</strong> Graph showing a bridge highlighted in red which ensures connectivity
</p>
<br><br>

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/articulate.webp?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[28]</strong> Articulation Points:Nodes whose removal increases the number of connected components in a graph.
</p>
<br>

- **Challenges:** Challenges: Identifying critical points of failure in the network.

- **Market Benefits:** Improved network reliability, and minimized downtime.

- **Design techniques and Performance analysis:**
     - **Bridges and Articulation Points**
          - Time complexity: O(V+E)
          - Space complexity:
              - Bridges:O(V+E)
              - Articulation Points:O(V)
           
[View Bridges code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/Bridges.cpp){:target="_blank"}<br>
[View Articulatr points code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/articulate.cpp){:target="_blank"}<br><br><br>


### 21.**Edge Node Selection Using MST Algorithms in VisaNet**
VisaNet relies on a global network of edge data centers to process transactions with low latency and high reliability.Efficiently connecting these edge nodes is critical, not every center needs to link with every other.Visa can be used **Minimum spanning tree** algorithms to optimize paths. 

Boruvka's algorithm: Visa can be used **Boruvka's algorithm** to optimize edge data center connectivity in parallel across regions.By repeatedly selecting the lowest-cost link for each node, Visa can rapidly form minimal-cost subnetworks.
<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/Boruvka's.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[29]</strong>Edge node selection using Boruvka's algorithm
</p>
<br>

Kruskal's Algorithm: **Kruskal's algorithm** can be used to connect nodes without forming cycles.Visa can use this to build acyclic communication between edge centers, when upgrading cross region connectivity.It's well-suited when link cost vary significantly,such as across oceans or between low and high-bandwidth providers.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/kruskals.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[30]</strong>Edge node selection using Kruskal's algorithm
</p>
<br>

Prim's algorithm: **Prim's algorithm** can be used to connect the closest edge data center at each step. Visa can use this method to grow its edge network from known backbone,such as a central infrastructure, ensuring each expansion prioritizes latency and reliability.

<p align="center">
  <img src="https://raw.githubusercontent.com/Daneshwari07/vica.github.io/main/images/Prim.gif?raw=true" style="width: 400px; height: auto;" alt="Run Length Encoding">
  <br>
  <strong>[31]</strong>Edge node selection using Prim's algorithm
</p>
<br>

- **Challenges:** Handling changes in latency,outages and bandwidth across regions in real time.

- **Market Benefits:** Faster Transation Processing,Cost efficiency.

- **Design techniques and Performance analysis:**
  
     - **Kruskal's Algorithm:** Greedy approach, Minimum Spanning Tree
          - Time complexity: O(E log E)
          - Space complexity: O(V+E)
  
     - **Prim's Algorithm:** Greedy approach, Minimum Spanning Tree
          - Time complexity:O(E log V) with priority queues (or (O(E + V log V)) with Fibonacci heaps)
          - Space complexity:O(V+E)

[View Kruskal's algorithm code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/kruskal.cpp){:target="_blank"}<br>
[View Prim's algorithm code here](https://github.com/Daneshwari07/visa.github.io/blob/main/codes/prim.cpp){:target="_blank"}<br><br><br> 


---
<br>
# 4.Use Case and Efficiency Overview

|SI. No.|Business Use Case                                    |Data Structure and Algorithm Used| Efficency (Time, Space complexity)|
|-------|-----------------------------------------------------|---------------------------------|-----------------------------------|
|   1   |Card and BIN Resolution for Visa Transaction Routing | Tries                           |   O(L), O(ALPHABET_SIZE*L)        |
|       |                                                     | Hash Table                      |   O(1), O(n)                      |
|       |                                                     | Skip Lists                      |   O(log n),O(n)                   |
|   2   |Routing Algorithms for Transaction Optimization      | Dijistra's algorithm            |   O((V+E)log V),O(V)              |
|       |                                                     | Floyd-Warshall algorithm        | O(V<sup>3</sup>), O(V<sup>2</sup>) |                             |   3   |Location Based Risk Check                            | KD-Tree                         |  O(n log n), O(n)                   |
|   4   |Network load balancing in VisaNet                    | Segment Tree                    |  O(n), O(n)                        |
|       |                                                     | Fenwick Tree                    |  O(n log n),O(n)                   |
|       |                                                     |Hash Table with consistent Hashing| O(1), O(n+k)                      |
|   5   |Secure Authentication and Encryption                 |Fermat's little theorem           |  O(log e), O(log n)                |
|       |                                                     | Red-Black Tree                   |  O(log n), O(n)                   |
|   6   |Keyword Detection in Customer Service Chatbots       | Aho-Corasick                     |  O(S), O(N+Z)                      |
|   7   |Allocation of resource in data centers               | Assignment Algorithm             |  O(2<sup>N</sup>+N),O(N<sup>2</sup>)|
|   8   |Scheduling Tasks in data centers                     | Topological sort                 |  O(V+E), O(V+E)                    |
|   9   |Resource Optimization in data centers                | Ford-Fulkerson Algorithm         |  O(E*V<sup>2</sup>),O(V<sup>2</sup>)|
|   10  |Optimal Transaction Bundle for Offers                | 0-1 KnapSack Algorithm           |  O(n*W), O(n*W)                     |
|       |                                                     | House Robber                     |  O(n), O(1)                        |
|   11  |Transaction Data Compression and Storage             | Huffman Coding                   |  O(n log n), O(n)                  |
|       |                                                     | Lempel-Ziv                       |  O(n), O(n)                        |
|       |                                                     | Run-Length Encoding              |  O(n), O(1)                        |
|   12  |Transaction Sequence Compression for AI Models       | Suffix Tree                      |  O(n), O(n)                        |
|   13  |Transaction History Analytics in VisaNet             | Persistent Segment Tree          |  O(log n), O(log n)                |
|       |                                                     | Fenwick Tree                     |  O(log n), O(n log n)              |
|   14  |Detecting fraud in Financial transaction             | Tries                            |  O(L), O(ALPHABET_SIZE*L)          |
|       |                                                     | Hash-Table                       |  O(1), O(n)                        |
|   15  |Risk Pattern Mining in VisaNet                       | Boyer Moore Algorithm            |  O(n*m), O(m+ALPHABET_SIZE)         |
|       |                                                     | Knuth-Morris-Pratt Algorithm     |  O(n+m), O(m)                      |
|       |                                                     | Rabin-Karp Algorithm             |  O(n+m), O(1)                      |
|   16  |Cross-Merchant Fraud Detection in VisaNet            | Kosaraju's Algorithm             |  O(V+E), O(V)                      |
|   17  |Merchant Similarity Scoring                          | Longest Common Subsequence       |  O(m*n), O(m*n)                    |
|   18  |Global Payment Clustering                            | Union-Find Data structure        |  O(Œ±(n)), O(n)                     |
|   19  |Dispute Resolution Workflow Optimization in VisaNet  | Topological Sort                 |  O(V+E), O(V+E)                    |
|       |                                                     | Stable Marriage Problem          |  O(n<sup>2</sup>), O(n<sup>2</sup>) |
|   20  |Network Reliability using Bridges and Articulation poins|Bridges                        |  O(V+E), O(V+E)                     |
|       |                                                     |  Articulation Points             |  O(V)                               |
|   21  | Edge Node Selection Using MST Algorithm in VisaNet  |  Kruskal's Algorithm             |  O(E log E), O(V+E)                 |
|       |                                                     |  Prim's Algorithm                |  O(E log V), O(V+E)                 |

---

**References** 

[1] VisaNet (2024) VisaNet. A network you can trust. Available at:[VisaNet](https://corporate.visa.com/en/about-visa/visanet.html){:target="_blank"}.

[2] Visa Direct makes it possible for fast, innovative and secure payments to travel across the world. Available:[Visa Direct ](https://corporate.visa.com/en/products/visa-direct.html){:target="_blank"}.

[3] Contactless Payments with Visa. Available:[VisaNet](https://www.visa.co.in/pay-with-visa/contactless-payments/contactless-payments.html){:target="_blank"}

[4] Gabriel Castro. "Trie Data Structure." Available at: [Gabriel Castro](https://gabrielcastro1028.medium.com/trie-data-structure-4a8becc97809){:target="_blank"}

[5] Junmin Lee."Hash Tables ‚Äî animations that will make you understand how they work" Available at: [Junmin Lee](https://junminlee3.medium.com/hash-tables-animations-that-will-make-you-understand-how-they-work-d1bcc850ba71){:target="_blank"}

[6] Wikipedia. "Skip List." Available at: [Wikipedia](https://en.wikipedia.org/wiki/Skip_list){:target="_blank"}.

[7] Sakshi Zod. "Shortest Path Algorithm" Available at: [Sakshi Zod](https://medium.com/@Sakshi_Zod/shortest-path-algorithm-af9de26a95b7){:target="_blank"}.

[8] Wikimedia Commons. "KDTree-animation" Available at: [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:KDTree-animation.gif){:target="_blank"}.

[9] Scaler Topics. "Segment Trees in Data Structure." Available at: [Scaler Topics](https://www.scaler.com/topics/data-structures/segment-trees-in-data-structure/){:target="_blank"}.

[10] Medium. "A Visual Introduction to Fenwick Tree" Available at: [Medium](https://medium.com/carpanese/a-visual-introduction-to-fenwick-tree-89b82cac5b3c){:target="_blank"}.

[11] Medium. "Load Balancing and Consistent Hashing" Available at: [Medium](https://medium.com/swlh/load-balancing-and-consistent-hashing-5fe0156035e1){:target="_blank"}. 

[12]Davidmaiolo(2024). " Impact of Fermat‚Äôs Little Theorem in Cryptography". Available :[Davidmaiolo](https://www.davidmaiolo.com/2024/03/10/exploring-impact-fermats-little-theorem-cryptography/){:target="_blank"}.

[13] FavTutor. "Aho-Corasick Algorithm for Pattern Searching". Available :[FavTutor](https://favtutor.com/blogs/aho-corasick-algorithm){:target="_blank"}.

[14] OpenGenus IQ. "Kahn's Algorithm for Topological Sort." Available at: [Fahadsultan](https://fahadsultan.com/csc223/datastructs/graphs_topo_kahn.html){:target="_blank"}.

[15] Wikipedia. "Ford-Fulkerson Algorithm Demo." Available at: [Wikipedia](https://en.m.wikipedia.org/wiki/File.gif){:target="_blank"}.

[16] Wikimedia Commons. "Huffman Algorithm Demonstration." Available at: [Wikimedia Commons](https://commons.wikimedia.org/wiki/File.gif){:target="_blank"}.

[17] "Run-length encoding". Available at: [Naukari](https://www.naukri.com/code360/library/run-length-encoding){:target="_blank"}

[18] Hackerearth. "Suffix Trees" Available at: [Hackerearth](https://www.hackerearth.com/practice/data-structures/advanced-data-structures/suffix-trees/tutorial/){:target="_blank"}.

[19]Geeksforgeeks. "Persistent Segment Tree" Available at: [GeeksforGeeks](https://www.geeksforgeeks.org/persistent-segment-tree-set-1-introduction/){:target="_blank"}

[20] FavTutor. "Boyer Moore Algorithm for Pattern Searching" Available at: [FavTutor](https://favtutor.com/blogs/boyer-moore-algorithm)

[21] Wikipedia. "Knuth‚ÄìMorris‚ÄìPratt algorithm" Available at: [Wikipedia](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm){:target="_blank"}.

[22]  Wikipedia. "Rabin‚ÄìKarp algorithm" Available at: [Wikipedia](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm){:target="_blank"}.

[23] Geeksforgeeks. "Strongly Connected Components" Available at: [GeeksforGeeks](https://www.geeksforgeeks.org/strongly-connected-components/){:target="_blank"}

[24] "Kosaraju Algorithm for Strongly Connected Components" Available at:[Kosaraju](https://vansikasingh13.medium.com/kosarajus-algorithm-for-strongly-connected-components-85e806274603){:target="_blank"}

[25] Wikipedia. "Tarjan's Strongly Connected Components Algorithm." Available at: [Wikipedia](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm){:target="_blank"}.

[26] Hackerearth. "Suffix Trees" Available at: [Hackerearth](https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/){:target="_blank"}.

[27] Wikipedia. "Topological Sorting" Available at: [Wikipedia](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm){:target="_blank"}.

[28] E-Olymp. "Bridges in Graph GIF." Available at: [E-Olymp](https://basecamp.eolymp.com/en/problems/1943){:target="_blank"}.

[29] GeeksforGeeks. "Articulation Points or Cut Vertices in a Graph." Available at: [GeeksforGeeks](https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/){:target="_blank"}.

[30] GeeksforGeeks. "Boruvka's algorithm " Available at: [GeeksforGeeks](https://www.geeksforgeeks.org/boruvkas-algorithm-greedy-algo-9/){:target="_blank"}.

[31] Make a GIF. "Kruskal Algorithm." Available at: [Make a GIF](https://makeagif.com/gif/kruskal-algorithm-IFvPaF){:target="_blank"}.

[32] Stack Overflow. "Prim's Algorithm Info." Available at: [Stack Overflow](https://stackoverflow.com/tags/prims-algorithm/info){:target="_blank"}.

